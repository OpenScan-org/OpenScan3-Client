// This file is auto-generated by @hey-api/openapi-ts

import type { Client, Options as Options2, TDataShape } from './client';
import { client } from './client.gen';
import type { AddConfigJsonData, AddConfigJsonErrors, AddConfigJsonResponses, AddScanWithDescriptionData, AddScanWithDescriptionErrors, AddScanWithDescriptionResponses, CancelFocusStackingData, CancelFocusStackingErrors, CancelFocusStackingResponses, CancelScanData, CancelScanErrors, CancelScanResponses, CancelTaskData, CancelTaskErrors, CancelTaskResponses, CreateTaskData, CreateTaskErrors, CreateTaskResponses, CropImageData, CropImageErrors, CropImageResponses, DeletePhotosData, DeletePhotosErrors, DeletePhotosResponses, DeleteProjectData, DeleteProjectErrors, DeleteProjectResponses, DeleteScanData, DeleteScanErrors, DeleteScanResponses, DownloadLogsArchiveData, DownloadLogsArchiveErrors, DownloadLogsArchiveResponses, DownloadProjectData, DownloadProjectErrors, DownloadProjectFromCloudData, DownloadProjectFromCloudErrors, DownloadProjectFromCloudResponses, DownloadProjectResponses, DownloadScansData, DownloadScansErrors, DownloadScansResponses, GetAllTasksData, GetAllTasksErrors, GetAllTasksResponses, GetCameraData, GetCameraErrors, GetCameraNameSettingsData, GetCameraNameSettingsErrors, GetCameraNameSettingsResponses, GetCameraResponses, GetCamerasData, GetCamerasErrors, GetCamerasResponses, GetCloudProjectData, GetCloudProjectErrors, GetCloudProjectResponses, GetCloudSettingsData, GetCloudSettingsErrors, GetCloudSettingsResponses, GetCloudStatusData, GetCloudStatusErrors, GetCloudStatusResponses, GetDeviceInfoData, GetDeviceInfoErrors, GetDeviceInfoResponses, GetLightData, GetLightErrors, GetLightNameSettingsData, GetLightNameSettingsErrors, GetLightNameSettingsResponses, GetLightResponses, GetLightsData, GetLightsErrors, GetLightsResponses, GetMotorData, GetMotorErrors, GetMotorNameSettingsData, GetMotorNameSettingsErrors, GetMotorNameSettingsResponses, GetMotorResponses, GetMotorsData, GetMotorsErrors, GetMotorsResponses, GetPathData, GetPathErrors, GetPathResponses, GetPhotoData, GetPhotoErrors, GetPhotoResponses, GetPinData, GetPinErrors, GetPinResponses, GetPinsData, GetPinsErrors, GetPinsResponses, GetPreviewData, GetPreviewErrors, GetPreviewResponses, GetProjectData, GetProjectErrors, GetProjectResponses, GetProjectsData, GetProjectsErrors, GetProjectsResponses, GetScanData, GetScanErrors, GetScanResponses, GetScanStatusData, GetScanStatusErrors, GetScanStatusResponses, GetSoftwareInfoData, GetSoftwareInfoErrors, GetSoftwareInfoResponses, GetTaskStatusData, GetTaskStatusErrors, GetTaskStatusResponses, HelloWorldAsyncData, HelloWorldAsyncErrors, HelloWorldAsyncResponses, ListCloudProjectsData, ListCloudProjectsErrors, ListCloudProjectsResponses, ListConfigFilesData, ListConfigFilesErrors, ListConfigFilesResponses, MoveMotorByDegreeData, MoveMotorByDegreeErrors, MoveMotorByDegreeResponses, MoveMotorToAngleData, MoveMotorToAngleErrors, MoveMotorToAngleResponses, MoveMotorToHomePositionData, MoveMotorToHomePositionErrors, MoveMotorToHomePositionResponses, MoveToPositionData, MoveToPositionErrors, MoveToPositionResponses, NewProjectData, NewProjectErrors, NewProjectResponses, PauseFocusStackingData, PauseFocusStackingErrors, PauseFocusStackingResponses, PauseScanData, PauseScanErrors, PauseScanResponses, PauseTaskData, PauseTaskErrors, PauseTaskResponses, RebootData, RebootErrors, RebootResponses, ReinitializeHardwareData, ReinitializeHardwareErrors, ReinitializeHardwareResponses, ReplaceCameraNameSettingsData, ReplaceCameraNameSettingsErrors, ReplaceCameraNameSettingsResponses, ReplaceLightNameSettingsData, ReplaceLightNameSettingsErrors, ReplaceLightNameSettingsResponses, ReplaceMotorNameSettingsData, ReplaceMotorNameSettingsErrors, ReplaceMotorNameSettingsResponses, ResetCloudProjectData, ResetCloudProjectErrors, ResetCloudProjectResponses, RestartApplicationData, RestartApplicationErrors, RestartApplicationResponses, RestartCameraData, RestartCameraErrors, RestartCameraResponses, ResumeFocusStackingData, ResumeFocusStackingErrors, ResumeFocusStackingResponses, ResumeScanData, ResumeScanErrors, ResumeScanResponses, ResumeTaskData, ResumeTaskErrors, ResumeTaskResponses, SaveDeviceConfigData, SaveDeviceConfigErrors, SaveDeviceConfigResponses, SetConfigFileData, SetConfigFileErrors, SetConfigFileResponses, SetPinData, SetPinErrors, SetPinResponses, ShutdownData, ShutdownErrors, ShutdownResponses, StartFocusStackingData, StartFocusStackingErrors, StartFocusStackingResponses, TailLogsData, TailLogsErrors, TailLogsResponses, ToggleLightData, ToggleLightErrors, ToggleLightResponses, TogglePinData, TogglePinErrors, TogglePinResponses, TurnOffLightData, TurnOffLightErrors, TurnOffLightResponses, TurnOnLightData, TurnOnLightErrors, TurnOnLightResponses, UpdateCameraNameSettingsData, UpdateCameraNameSettingsErrors, UpdateCameraNameSettingsResponses, UpdateCloudSettingsData, UpdateCloudSettingsErrors, UpdateCloudSettingsResponses, UpdateLightNameSettingsData, UpdateLightNameSettingsErrors, UpdateLightNameSettingsResponses, UpdateMotorNameSettingsData, UpdateMotorNameSettingsErrors, UpdateMotorNameSettingsResponses, UploadProjectToCloudData, UploadProjectToCloudErrors, UploadProjectToCloudResponses } from './types.gen';

export type Options<TData extends TDataShape = TDataShape, ThrowOnError extends boolean = boolean> = Options2<TData, ThrowOnError> & {
    /**
     * You can provide a client instance returned by `createClient()` instead of
     * individual options. This might be also useful if you want to implement a
     * custom client.
     */
    client?: Client;
    /**
     * You can pass arbitrary values through the `meta` object. This can be
     * used to access values that aren't defined as part of the SDK function.
     */
    meta?: Record<string, unknown>;
};

/**
 * Get Cameras
 *
 * Get all cameras with their current status
 *
 * Returns:
 * dict[str, CameraStatusResponse]: A dictionary of camera name to a camera status object
 */
export const getCameras = <ThrowOnError extends boolean = false>(options?: Options<GetCamerasData, ThrowOnError>) => (options?.client ?? client).get<GetCamerasResponses, GetCamerasErrors, ThrowOnError>({ url: '/cameras/', ...options });

/**
 * Get Camera
 *
 * Get a camera with its current status
 *
 * Args:
 * camera_name: The name of the camera to get the status of
 *
 * Returns:
 * CameraStatusResponse: A response object containing the status of the camera
 */
export const getCamera = <ThrowOnError extends boolean = false>(options: Options<GetCameraData, ThrowOnError>) => (options.client ?? client).get<GetCameraResponses, GetCameraErrors, ThrowOnError>({ url: '/cameras/{camera_name}', ...options });

/**
 * Get Preview
 *
 * Get a camera preview stream in lower resolution
 *
 * Args:
 * camera_name: The name of the camera to get the preview stream from
 *
 * Returns:
 * StreamingResponse: A streaming response containing the preview stream
 */
export const getPreview = <ThrowOnError extends boolean = false>(options: Options<GetPreviewData, ThrowOnError>) => (options.client ?? client).get<GetPreviewResponses, GetPreviewErrors, ThrowOnError>({ url: '/cameras/{camera_name}/preview', ...options });

/**
 * Get Photo
 *
 * Get a camera photo
 *
 * Args:
 * camera_name: The name of the camera to get the photo from
 *
 * Returns:
 * Response: A response containing the photo
 */
export const getPhoto = <ThrowOnError extends boolean = false>(options: Options<GetPhotoData, ThrowOnError>) => (options.client ?? client).get<GetPhotoResponses, GetPhotoErrors, ThrowOnError>({ url: '/cameras/{camera_name}/photo', ...options });

/**
 * Restart Camera
 *
 * Restart a camera
 *
 * Args:
 * camera_name: The name of the camera to restart
 *
 * Returns:
 * Response: A response containing the status code
 */
export const restartCamera = <ThrowOnError extends boolean = false>(options: Options<RestartCameraData, ThrowOnError>) => (options.client ?? client).post<RestartCameraResponses, RestartCameraErrors, ThrowOnError>({ url: '/cameras/{camera_name}/restart', ...options });

/**
 * Get Camera Name Settings
 *
 * Get settings for a specific resource
 */
export const getCameraNameSettings = <ThrowOnError extends boolean = false>(options: Options<GetCameraNameSettingsData, ThrowOnError>) => (options.client ?? client).get<GetCameraNameSettingsResponses, GetCameraNameSettingsErrors, ThrowOnError>({ url: '/cameras/{name}/settings', ...options });

/**
 * Update Camera Name Settings
 *
 * Update one or more specific settings for a resource
 *
 * Args:
 * name: The name of the resource to update settings for
 * settings: A dictionary of settings to update
 *
 * Returns:
 * The updated settings for the resource
 */
export const updateCameraNameSettings = <ThrowOnError extends boolean = false>(options: Options<UpdateCameraNameSettingsData, ThrowOnError>) => (options.client ?? client).patch<UpdateCameraNameSettingsResponses, UpdateCameraNameSettingsErrors, ThrowOnError>({
    url: '/cameras/{name}/settings',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Replace Camera Name Settings
 *
 * Replace all settings for a specific resource
 *
 * Args:
 * name: The name of the resource to replace settings for
 * settings: The new settings for the resource
 *
 * Returns:
 * The updated settings for the resource
 */
export const replaceCameraNameSettings = <ThrowOnError extends boolean = false>(options: Options<ReplaceCameraNameSettingsData, ThrowOnError>) => (options.client ?? client).put<ReplaceCameraNameSettingsResponses, ReplaceCameraNameSettingsErrors, ThrowOnError>({ url: '/cameras/{name}/settings', ...options });

/**
 * Get Motors
 *
 * Get all motors with their current status
 *
 * Returns:
 * dict[str, MotorStatusResponse]: A dictionary of motor name to a motor status object
 */
export const getMotors = <ThrowOnError extends boolean = false>(options?: Options<GetMotorsData, ThrowOnError>) => (options?.client ?? client).get<GetMotorsResponses, GetMotorsErrors, ThrowOnError>({ url: '/motors/', ...options });

/**
 * Get Motor
 *
 * Get motor status
 *
 * Args:
 * motor_name: The name of the motor to get the status of
 *
 * Returns:
 * MotorStatusResponse: A response object containing the status of the motor
 */
export const getMotor = <ThrowOnError extends boolean = false>(options: Options<GetMotorData, ThrowOnError>) => (options.client ?? client).get<GetMotorResponses, GetMotorErrors, ThrowOnError>({ url: '/motors/{motor_name}', ...options });

/**
 * Move Motor By Degree
 *
 * Move motor by degrees
 *
 * Args:
 * motor_name: The name of the motor to move
 * degrees: Number of degrees to move
 *
 * Returns:
 * MotorStatusResponse: A response object containing the status of the motor after the move
 */
export const moveMotorByDegree = <ThrowOnError extends boolean = false>(options: Options<MoveMotorByDegreeData, ThrowOnError>) => (options.client ?? client).patch<MoveMotorByDegreeResponses, MoveMotorByDegreeErrors, ThrowOnError>({
    url: '/motors/{motor_name}/angle',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Move Motor To Angle
 *
 * Move motor to absolute position
 *
 * Args:
 * motor_name: The name of the motor to move
 * degrees: Number of degrees to move
 *
 * Returns:
 * MotorStatusResponse: A response object containing the status of the motor after the move
 */
export const moveMotorToAngle = <ThrowOnError extends boolean = false>(options: Options<MoveMotorToAngleData, ThrowOnError>) => (options.client ?? client).put<MoveMotorToAngleResponses, MoveMotorToAngleErrors, ThrowOnError>({ url: '/motors/{motor_name}/angle', ...options });

/**
 * Move Motor To Home Position
 *
 * Move motor to home position
 *
 * This endpoint moves the motor to the home position using the endstop calibration.
 *
 * Args:
 * motor_name: The name of the motor to move to the home position
 *
 * Returns:
 * MotorStatusResponse: A response object containing the status of the motor after the move
 */
export const moveMotorToHomePosition = <ThrowOnError extends boolean = false>(options: Options<MoveMotorToHomePositionData, ThrowOnError>) => (options.client ?? client).put<MoveMotorToHomePositionResponses, MoveMotorToHomePositionErrors, ThrowOnError>({ url: '/motors/{motor_name}/endstop-calibration', ...options });

/**
 * Get Motor Name Settings
 *
 * Get settings for a specific resource
 */
export const getMotorNameSettings = <ThrowOnError extends boolean = false>(options: Options<GetMotorNameSettingsData, ThrowOnError>) => (options.client ?? client).get<GetMotorNameSettingsResponses, GetMotorNameSettingsErrors, ThrowOnError>({ url: '/motors/{name}/settings', ...options });

/**
 * Update Motor Name Settings
 *
 * Update one or more specific settings for a resource
 *
 * Args:
 * name: The name of the resource to update settings for
 * settings: A dictionary of settings to update
 *
 * Returns:
 * The updated settings for the resource
 */
export const updateMotorNameSettings = <ThrowOnError extends boolean = false>(options: Options<UpdateMotorNameSettingsData, ThrowOnError>) => (options.client ?? client).patch<UpdateMotorNameSettingsResponses, UpdateMotorNameSettingsErrors, ThrowOnError>({
    url: '/motors/{name}/settings',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Replace Motor Name Settings
 *
 * Replace all settings for a specific resource
 *
 * Args:
 * name: The name of the resource to replace settings for
 * settings: The new settings for the resource
 *
 * Returns:
 * The updated settings for the resource
 */
export const replaceMotorNameSettings = <ThrowOnError extends boolean = false>(options: Options<ReplaceMotorNameSettingsData, ThrowOnError>) => (options.client ?? client).put<ReplaceMotorNameSettingsResponses, ReplaceMotorNameSettingsErrors, ThrowOnError>({ url: '/motors/{name}/settings', ...options });

/**
 * Get Lights
 *
 * Get all lights with their current status
 *
 * Returns:
 * dict[str, LightStatusResponse]: A dictionary of light name to a light status object
 */
export const getLights = <ThrowOnError extends boolean = false>(options?: Options<GetLightsData, ThrowOnError>) => (options?.client ?? client).get<GetLightsResponses, GetLightsErrors, ThrowOnError>({ url: '/lights/', ...options });

/**
 * Get Light
 *
 * Get light status
 *
 * Args:
 * light_name: The name of the light to get the status of
 *
 * Returns:
 * LightStatusResponse: A response object containing the status of the light
 */
export const getLight = <ThrowOnError extends boolean = false>(options: Options<GetLightData, ThrowOnError>) => (options.client ?? client).get<GetLightResponses, GetLightErrors, ThrowOnError>({ url: '/lights/{light_name}', ...options });

/**
 * Turn On Light
 *
 * Turn on light
 *
 * Args:
 * light_name: The name of the light to turn on
 *
 * Returns:
 * LightStatusResponse: A response object containing the status of the light after the turn on operation
 */
export const turnOnLight = <ThrowOnError extends boolean = false>(options: Options<TurnOnLightData, ThrowOnError>) => (options.client ?? client).patch<TurnOnLightResponses, TurnOnLightErrors, ThrowOnError>({ url: '/lights/{light_name}/turn_on', ...options });

/**
 * Turn Off Light
 *
 * Turn of light
 *
 * Args:
 * light_name: The name of the light to turn off
 *
 * Returns:
 * LightStatusResponse: A response object containing the status of the light after the turn off operation
 */
export const turnOffLight = <ThrowOnError extends boolean = false>(options: Options<TurnOffLightData, ThrowOnError>) => (options.client ?? client).patch<TurnOffLightResponses, TurnOffLightErrors, ThrowOnError>({ url: '/lights/{light_name}/turn_off', ...options });

/**
 * Toggle Light
 *
 * Toggle light on or off
 *
 * Args:
 * light_name: The name of the light to toggle
 *
 * Returns:
 * LightStatusResponse: A response object containing the status of the light after the toggle operation
 */
export const toggleLight = <ThrowOnError extends boolean = false>(options: Options<ToggleLightData, ThrowOnError>) => (options.client ?? client).patch<ToggleLightResponses, ToggleLightErrors, ThrowOnError>({ url: '/lights/{light_name}/toggle', ...options });

/**
 * Get Light Name Settings
 *
 * Get settings for a specific resource
 */
export const getLightNameSettings = <ThrowOnError extends boolean = false>(options: Options<GetLightNameSettingsData, ThrowOnError>) => (options.client ?? client).get<GetLightNameSettingsResponses, GetLightNameSettingsErrors, ThrowOnError>({ url: '/lights/{name}/settings', ...options });

/**
 * Update Light Name Settings
 *
 * Update one or more specific settings for a resource
 *
 * Args:
 * name: The name of the resource to update settings for
 * settings: A dictionary of settings to update
 *
 * Returns:
 * The updated settings for the resource
 */
export const updateLightNameSettings = <ThrowOnError extends boolean = false>(options: Options<UpdateLightNameSettingsData, ThrowOnError>) => (options.client ?? client).patch<UpdateLightNameSettingsResponses, UpdateLightNameSettingsErrors, ThrowOnError>({
    url: '/lights/{name}/settings',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Replace Light Name Settings
 *
 * Replace all settings for a specific resource
 *
 * Args:
 * name: The name of the resource to replace settings for
 * settings: The new settings for the resource
 *
 * Returns:
 * The updated settings for the resource
 */
export const replaceLightNameSettings = <ThrowOnError extends boolean = false>(options: Options<ReplaceLightNameSettingsData, ThrowOnError>) => (options.client ?? client).put<ReplaceLightNameSettingsResponses, ReplaceLightNameSettingsErrors, ThrowOnError>({ url: '/lights/{name}/settings', ...options });

/**
 * Get Projects
 *
 * Get all projects with serialized data
 *
 * Returns:
 * dict[str, Project]: A dictionary of project name to a project object
 */
export const getProjects = <ThrowOnError extends boolean = false>(options?: Options<GetProjectsData, ThrowOnError>) => (options?.client ?? client).get<GetProjectsResponses, GetProjectsErrors, ThrowOnError>({ url: '/projects/', ...options });

/**
 * Delete Project
 *
 * Delete a project
 *
 * Args:
 * project_name: The name of the project to delete
 *
 * Returns:
 * DeleteResponse: A response object containing the result of the deletion
 */
export const deleteProject = <ThrowOnError extends boolean = false>(options: Options<DeleteProjectData, ThrowOnError>) => (options.client ?? client).delete<DeleteProjectResponses, DeleteProjectErrors, ThrowOnError>({ url: '/projects/{project_name}', ...options });

/**
 * Get Project
 *
 * Get a project
 *
 * Args:
 * project_name: The name of the project to get
 *
 * Returns:
 * Project: The project object if found, None if not
 */
export const getProject = <ThrowOnError extends boolean = false>(options: Options<GetProjectData, ThrowOnError>) => (options.client ?? client).get<GetProjectResponses, GetProjectErrors, ThrowOnError>({ url: '/projects/{project_name}', ...options });

/**
 * New Project
 *
 * Create a new project
 *
 * Args:
 * project_name: The name of the project to create
 * project_description: Optional description for the project
 *
 * Returns:
 * Project: The newly created project if successful, None if not
 */
export const newProject = <ThrowOnError extends boolean = false>(options: Options<NewProjectData, ThrowOnError>) => (options.client ?? client).post<NewProjectResponses, NewProjectErrors, ThrowOnError>({ url: '/projects/{project_name}', ...options });

/**
 * Add Scan With Description
 *
 * Add a new scan to a project and return the created Task
 *
 * Args:
 * project_name: The name of the project to add the scan to
 * camera_name: The name of the camera to use for the scan
 * scan_settings: The settings for the scan
 * scan_description: Optional description for the scan
 *
 * Returns:
 * Task: The Task representing the started scan
 */
export const addScanWithDescription = <ThrowOnError extends boolean = false>(options: Options<AddScanWithDescriptionData, ThrowOnError>) => (options.client ?? client).post<AddScanWithDescriptionResponses, AddScanWithDescriptionErrors, ThrowOnError>({
    url: '/projects/{project_name}/scan',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Upload Project To Cloud
 *
 * Schedule an asynchronous cloud upload for a project.
 *
 * Args:
 * project_name: The name of the project
 * token_override: Optional token override
 *
 * Returns:
 * Task: The TaskManager model describing the scheduled upload
 */
export const uploadProjectToCloud = <ThrowOnError extends boolean = false>(options: Options<UploadProjectToCloudData, ThrowOnError>) => (options.client ?? client).post<UploadProjectToCloudResponses, UploadProjectToCloudErrors, ThrowOnError>({ url: '/projects/{project_name}/upload', ...options });

/**
 * Download Project From Cloud
 *
 * Schedule an asynchronous cloud download for a project's reconstruction.
 *
 * Args:
 * project_name: The name of the project
 * token_override: Optional token override
 * remote_project: Optional explicit remote project name, defaults to the stored cloud name
 *
 * Returns:
 * Task: The TaskManager model describing the scheduled download
 */
export const downloadProjectFromCloud = <ThrowOnError extends boolean = false>(options: Options<DownloadProjectFromCloudData, ThrowOnError>) => (options.client ?? client).post<DownloadProjectFromCloudResponses, DownloadProjectFromCloudErrors, ThrowOnError>({ url: '/projects/{project_name}/download', ...options });

/**
 * Delete Photos
 *
 * Delete photos from a scan in a project
 *
 * Args:
 * project_name: The name of the project
 * scan_index: The index of the scan
 * photo_filenames: A list of photo filenames to delete
 *
 * Returns:
 * True if the photos were deleted successfully, False otherwise
 */
export const deletePhotos = <ThrowOnError extends boolean = false>(options: Options<DeletePhotosData, ThrowOnError>) => (options.client ?? client).delete<DeletePhotosResponses, DeletePhotosErrors, ThrowOnError>({
    url: '/projects/{project_name}/{scan_index}/photos',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Delete Scan
 *
 * Delete a scan from a project
 *
 * Args:
 * project_name: The name of the project
 * scan_index: The index of the scan to delete
 *
 * Returns:
 * DeleteResponse: Result of the deletion operation
 */
export const deleteScan = <ThrowOnError extends boolean = false>(options: Options<DeleteScanData, ThrowOnError>) => (options.client ?? client).delete<DeleteScanResponses, DeleteScanErrors, ThrowOnError>({ url: '/projects/{project_name}/scans/{scan_index}', ...options });

/**
 * Get Scan
 *
 * Get Scan by project and index
 *
 * Args:
 * project_name: The name of the project
 * scan_index: The index of the scan
 *
 * Returns:
 * Scan: The scan object
 */
export const getScan = <ThrowOnError extends boolean = false>(options: Options<GetScanData, ThrowOnError>) => (options.client ?? client).get<GetScanResponses, GetScanErrors, ThrowOnError>({ url: '/projects/{project_name}/scans/{scan_index}', ...options });

/**
 * Get Scan Status
 *
 * Get the current task for a scan
 *
 * Args:
 * project_name: The name of the project
 * scan_index: The index of the scan to get the status of
 *
 * Returns:
 * Task: The task representing the scan execution
 */
export const getScanStatus = <ThrowOnError extends boolean = false>(options: Options<GetScanStatusData, ThrowOnError>) => (options.client ?? client).get<GetScanStatusResponses, GetScanStatusErrors, ThrowOnError>({ url: '/projects/{project_name}/scans/{scan_index}/status', ...options });

/**
 * Pause Scan
 *
 * Pause a running scan and return the updated Task
 *
 * Args:
 * project_name: The name of the project
 * scan_index: The index of the scan to pause
 *
 * Returns:
 * Task: The updated task state
 */
export const pauseScan = <ThrowOnError extends boolean = false>(options: Options<PauseScanData, ThrowOnError>) => (options.client ?? client).patch<PauseScanResponses, PauseScanErrors, ThrowOnError>({ url: '/projects/{project_name}/scans/{scan_index}/pause', ...options });

/**
 * Resume Scan
 *
 * Resume a paused, cancelled or failed scan and return the resulting Task
 *
 * Args:
 * project_name: The name of the project
 * scan_index: The index of the scan to resume
 * camera_name: The name of the camera to use for the scan
 *
 * Returns:
 * Task: The resumed or restarted task
 */
export const resumeScan = <ThrowOnError extends boolean = false>(options: Options<ResumeScanData, ThrowOnError>) => (options.client ?? client).patch<ResumeScanResponses, ResumeScanErrors, ThrowOnError>({ url: '/projects/{project_name}/scans/{scan_index}/resume', ...options });

/**
 * Cancel Scan
 *
 * Cancel a running scan and return the resulting Task
 *
 * Args:
 * project_name: The name of the project
 * scan_index: The index of the scan to cancel
 *
 * Returns:
 * Task: The updated task state
 */
export const cancelScan = <ThrowOnError extends boolean = false>(options: Options<CancelScanData, ThrowOnError>) => (options.client ?? client).patch<CancelScanResponses, CancelScanErrors, ThrowOnError>({ url: '/projects/{project_name}/scans/{scan_index}/cancel', ...options });

/**
 * Download Project
 *
 * Download a project as a ZIP file stream
 *
 * This endpoint streams the entire project directory as a ZIP file,
 * including all scans, photos, and metadata.
 *
 * Args:
 * project_name: Name of the project to download
 *
 * Returns:
 * StreamingResponse: ZIP file stream
 */
export const downloadProject = <ThrowOnError extends boolean = false>(options: Options<DownloadProjectData, ThrowOnError>) => (options.client ?? client).get<DownloadProjectResponses, DownloadProjectErrors, ThrowOnError>({ url: '/projects/{project_name}/zip', ...options });

/**
 * Download Scans
 *
 * Download selected scans from a project as a ZIP file stream
 *
 * This endpoint streams selected scans from a project as a ZIP file.
 * If no scan indices are provided, all scans will be included.
 *
 * Args:
 * project_name: Name of the project
 * scan_indices: List of scan indices to include in the ZIP file
 *
 * Returns:
 * StreamingResponse: ZIP file stream
 */
export const downloadScans = <ThrowOnError extends boolean = false>(options: Options<DownloadScansData, ThrowOnError>) => (options.client ?? client).get<DownloadScansResponses, DownloadScansErrors, ThrowOnError>({ url: '/projects/{project_name}/scans/zip', ...options });

/**
 * Get Pins
 *
 * Get all initialized GPIO pins
 *
 * Returns:
 * dict[str, list[int]]: A dictionary of initialized output pins and buttons
 */
export const getPins = <ThrowOnError extends boolean = false>(options?: Options<GetPinsData, ThrowOnError>) => (options?.client ?? client).get<GetPinsResponses, GetPinsErrors, ThrowOnError>({ url: '/gpio/', ...options });

/**
 * Get Pin
 *
 * Get output value of a specific GPIO pin
 *
 * Args:
 * pin_id: The ID (int) of the GPIO pin to get the value of
 *
 * Returns:
 * bool: The output value of the GPIO pin
 */
export const getPin = <ThrowOnError extends boolean = false>(options: Options<GetPinData, ThrowOnError>) => (options.client ?? client).get<GetPinResponses, GetPinErrors, ThrowOnError>({ url: '/gpio/{pin_id}', ...options });

/**
 * Set Pin
 *
 * Set GPIO pin output value
 *
 * Args:
 * pin_id: The ID (int) of the GPIO pin to set the value of
 * status: The output value to set for the GPIO pin
 */
export const setPin = <ThrowOnError extends boolean = false>(options: Options<SetPinData, ThrowOnError>) => (options.client ?? client).patch<SetPinResponses, SetPinErrors, ThrowOnError>({ url: '/gpio/{pin_id}', ...options });

/**
 * Toggle Pin
 *
 * Toggle GPIO pin output value
 *
 * Args:
 * pin_id: The ID (int) of the GPIO pin to toggle
 */
export const togglePin = <ThrowOnError extends boolean = false>(options: Options<TogglePinData, ThrowOnError>) => (options.client ?? client).patch<TogglePinResponses, TogglePinErrors, ThrowOnError>({ url: '/gpio/{pin_id}/toggle', ...options });

/**
 * Get Software Info
 *
 * Get information about the scanner software
 */
export const getSoftwareInfo = <ThrowOnError extends boolean = false>(options?: Options<GetSoftwareInfoData, ThrowOnError>) => (options?.client ?? client).get<GetSoftwareInfoResponses, GetSoftwareInfoErrors, ThrowOnError>({ url: '/', ...options });

/**
 * Tail Logs
 *
 * Show or follow current logs.
 *
 * When follow=false (default), returns the last N lines of the selected log.
 * When follow=true (text mode only!), streams new lines as they are written (like `tail -f`).
 *
 * Args:
 * format: "text" for openscan.log, "json" for openscan_detailed_log.json.
 * lines: Number of last lines to return initially.
 * follow: If true, stream appended log lines in text mode.
 * poll_interval: Poll interval (seconds) when following in text mode.
 *
 * Returns:
 * A response with the requested log content.
 */
export const tailLogs = <ThrowOnError extends boolean = false>(options?: Options<TailLogsData, ThrowOnError>) => (options?.client ?? client).get<TailLogsResponses, TailLogsErrors, ThrowOnError>({ url: '/logs/tail', ...options });

/**
 * Download Logs Archive
 *
 * Create and download a ZIP archive containing all log files.
 *
 * The archive includes rotated files for both text and JSON logs, using
 * deflate compression for reasonable size to share e.g. via email.
 *
 * Returns:
 * FileResponse serving the generated ZIP. The temp file is deleted after send.
 */
export const downloadLogsArchive = <ThrowOnError extends boolean = false>(options?: Options<DownloadLogsArchiveData, ThrowOnError>) => (options?.client ?? client).get<DownloadLogsArchiveResponses, DownloadLogsArchiveErrors, ThrowOnError>({ url: '/logs/archive', ...options });

/**
 * Get Device Info
 *
 * Get information about the device
 *
 * Returns:
 * dict: A dictionary containing information about the device
 */
export const getDeviceInfo = <ThrowOnError extends boolean = false>(options?: Options<GetDeviceInfoData, ThrowOnError>) => (options?.client ?? client).get<GetDeviceInfoResponses, GetDeviceInfoErrors, ThrowOnError>({ url: '/device/info', ...options });

/**
 * List Config Files
 *
 * List all available device configuration files
 */
export const listConfigFiles = <ThrowOnError extends boolean = false>(options?: Options<ListConfigFilesData, ThrowOnError>) => (options?.client ?? client).get<ListConfigFilesResponses, ListConfigFilesErrors, ThrowOnError>({ url: '/device/configurations', ...options });

/**
 * Add Config Json
 *
 * Add a device configuration from a JSON object
 *
 * This endpoint accepts a JSON object with the device configuration,
 * validates it and saves it to a file.
 *
 * Args:
 * config_data: The device configuration to add
 * filename: The filename to save the configuration as
 *
 * Returns:
 * dict: A dictionary containing the status of the operation
 */
export const addConfigJson = <ThrowOnError extends boolean = false>(options: Options<AddConfigJsonData, ThrowOnError>) => (options.client ?? client).post<AddConfigJsonResponses, AddConfigJsonErrors, ThrowOnError>({
    url: '/device/configurations/',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Save Device Config
 *
 * Save the current device configuration to a file
 *
 * This endpoint saves the current device configuration to device_config.json.
 *
 * Returns:
 * dict: A dictionary containing the status of the operation
 */
export const saveDeviceConfig = <ThrowOnError extends boolean = false>(options?: Options<SaveDeviceConfigData, ThrowOnError>) => (options?.client ?? client).patch<SaveDeviceConfigResponses, SaveDeviceConfigErrors, ThrowOnError>({ url: '/device/configurations/current', ...options });

/**
 * Set Config File
 *
 * Set the device configuration from a file and initialize hardware
 *
 * Args:
 * config_data: The device configuration to set
 *
 * Returns:
 * dict: A dictionary containing the status of the operation
 */
export const setConfigFile = <ThrowOnError extends boolean = false>(options: Options<SetConfigFileData, ThrowOnError>) => (options.client ?? client).put<SetConfigFileResponses, SetConfigFileErrors, ThrowOnError>({
    url: '/device/configurations/current',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Reinitialize Hardware
 *
 * Reinitialize hardware components
 *
 * This can be used in case of a hardware failure or to reload the hardware components.
 *
 * Args:
 * detect_cameras: Whether to detect cameras
 *
 * Returns:
 * dict: A dictionary containing the status of the operation
 */
export const reinitializeHardware = <ThrowOnError extends boolean = false>(options?: Options<ReinitializeHardwareData, ThrowOnError>) => (options?.client ?? client).post<ReinitializeHardwareResponses, ReinitializeHardwareErrors, ThrowOnError>({ url: '/device/configurations/current/initialize', ...options });

/**
 * Reboot
 *
 * Reboot system and optionally save config.
 *
 * Args:
 * save_config: Whether to save the current configuration before rebooting
 */
export const reboot = <ThrowOnError extends boolean = false>(options?: Options<RebootData, ThrowOnError>) => (options?.client ?? client).post<RebootResponses, RebootErrors, ThrowOnError>({ url: '/device/reboot', ...options });

/**
 * Shutdown
 *
 * Shutdown system and optionally save config.
 *
 * Args:
 * save_config: Whether to save the current configuration before shutting down
 */
export const shutdown = <ThrowOnError extends boolean = false>(options?: Options<ShutdownData, ThrowOnError>) => (options?.client ?? client).post<ShutdownResponses, ShutdownErrors, ThrowOnError>({ url: '/device/shutdown', ...options });

/**
 * Get All Tasks
 *
 * Retrieve a list of all tasks known to the task manager.
 *
 * Returns:
 * List[Task]: A list of all tasks known to the task manager.
 */
export const getAllTasks = <ThrowOnError extends boolean = false>(options?: Options<GetAllTasksData, ThrowOnError>) => (options?.client ?? client).get<GetAllTasksResponses, GetAllTasksErrors, ThrowOnError>({ url: '/tasks/', ...options });

/**
 * Cancel Task
 *
 * Request cancellation of a running task.
 *
 * Args:
 * task_id: The ID of the task to cancel.
 *
 * Returns:
 * Task: The task object with its status and details.
 */
export const cancelTask = <ThrowOnError extends boolean = false>(options: Options<CancelTaskData, ThrowOnError>) => (options.client ?? client).delete<CancelTaskResponses, CancelTaskErrors, ThrowOnError>({ url: '/tasks/{task_id}', ...options });

/**
 * Get Task Status
 *
 * Retrieve the status and details of a specific task.
 *
 * Args:
 * task_id: The ID of the task to retrieve.
 *
 * Returns:
 * Task: The task object with its status and details.
 */
export const getTaskStatus = <ThrowOnError extends boolean = false>(options: Options<GetTaskStatusData, ThrowOnError>) => (options.client ?? client).get<GetTaskStatusResponses, GetTaskStatusErrors, ThrowOnError>({ url: '/tasks/{task_id}', ...options });

/**
 * Pause a Task
 *
 * Pauses a running task.
 *
 * Args:
 * task_id: The ID of the task to pause.
 *
 * Returns:
 * Task: The task object with its status and details.
 */
export const pauseTask = <ThrowOnError extends boolean = false>(options: Options<PauseTaskData, ThrowOnError>) => (options.client ?? client).post<PauseTaskResponses, PauseTaskErrors, ThrowOnError>({ url: '/tasks/{task_id}/pause', ...options });

/**
 * Resume a Task
 *
 * Resumes a paused task.
 *
 * Args:
 * task_id: The ID of the task to resume.
 *
 * Returns:
 * Task: The task object with its status and details.
 */
export const resumeTask = <ThrowOnError extends boolean = false>(options: Options<ResumeTaskData, ThrowOnError>) => (options.client ?? client).post<ResumeTaskResponses, ResumeTaskErrors, ThrowOnError>({ url: '/tasks/{task_id}/resume', ...options });

/**
 * Create Task
 *
 * Create and start a new background task with optional parameters.
 *
 * The request body accepts:
 * - **args**: List of positional arguments (e.g., `["project_name", 0]`)
 * - **kwargs**: Dictionary of keyword arguments (e.g., `{"num_batches": 5}`)
 *
 * Args:
 * task_name: The name of the task to create, as registered in the TaskManager.
 * args: Positional arguments to pass to the task's run method.
 * kwargs: Keyword arguments to pass to the task's run method.
 *
 * Returns:
 * The created task object.
 *
 * Examples:
 * ```json
 * // No parameters
 * {}
 *
 * // With positional args
 * {
 * "args": ["MyProject", 0]
 * }
 *
 * // With keyword args
 * {
 * "kwargs": {"num_calibration_batches": 5}
 * }
 *
 * // With both
 * {
 * "args": ["MyProject", 0],
 * "kwargs": {"num_calibration_batches": 5}
 * }
 * ```
 */
export const createTask = <ThrowOnError extends boolean = false>(options: Options<CreateTaskData, ThrowOnError>) => (options.client ?? client).post<CreateTaskResponses, CreateTaskErrors, ThrowOnError>({
    url: '/tasks/{task_name}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Move To Position
 *
 * Move Rotor and Turntable to a polar point
 */
export const moveToPosition = <ThrowOnError extends boolean = false>(options: Options<MoveToPositionData, ThrowOnError>) => (options.client ?? client).put<MoveToPositionResponses, MoveToPositionErrors, ThrowOnError>({
    url: '/develop/scanner-position',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Restart Application
 *
 * Trigger a Firmware reload by touching the reload sentinel file.
 *
 * Note: The application has to be started with the --reload-trigger option to enable this endpoint.
 */
export const restartApplication = <ThrowOnError extends boolean = false>(options?: Options<RestartApplicationData, ThrowOnError>) => (options?.client ?? client).post<RestartApplicationResponses, RestartApplicationErrors, ThrowOnError>({ url: '/develop/restart', ...options });

/**
 * Run crop task and return visualization image
 *
 * Run the crop task and return the visualization image with bounding boxes.
 *
 * Args:
 * camera_name: Name of the camera controller to use.
 * threshold: Optional Canny threshold passed to the analysis (tutorial uses a trackbar). If not set, defaults inside the task.
 *
 * Returns:
 * Response: JPEG image showing contours, rectangles and circles as detected by the task.
 */
export const cropImage = <ThrowOnError extends boolean = false>(options: Options<CropImageData, ThrowOnError>) => (options.client ?? client).get<CropImageResponses, CropImageErrors, ThrowOnError>({ url: '/develop/crop_image', ...options });

/**
 * Hello World Async
 *
 * Start the async hello world demo task.
 */
export const helloWorldAsync = <ThrowOnError extends boolean = false>(options: Options<HelloWorldAsyncData, ThrowOnError>) => (options.client ?? client).post<HelloWorldAsyncResponses, HelloWorldAsyncErrors, ThrowOnError>({ url: '/develop/hello-world-async', ...options });

/**
 * Get Path
 *
 * Get a list of coordinates by path method and number of points
 */
export const getPath = <ThrowOnError extends boolean = false>(options: Options<GetPathData, ThrowOnError>) => (options.client ?? client).get<GetPathResponses, GetPathErrors, ThrowOnError>({ url: '/develop/{method}', ...options });

/**
 * Get Cloud Status
 *
 * Return aggregated status information for the cloud backend.
 *
 * Returns:
 * CloudStatusResponse: A response object containing the status of the cloud backend
 */
export const getCloudStatus = <ThrowOnError extends boolean = false>(options?: Options<GetCloudStatusData, ThrowOnError>) => (options?.client ?? client).get<GetCloudStatusResponses, GetCloudStatusErrors, ThrowOnError>({ url: '/cloud/status', ...options });

/**
 * Get Cloud Settings
 *
 * Return the masked active cloud configuration.
 *
 * Returns:
 * CloudSettingsResponse: A response object containing the masked active cloud configuration
 */
export const getCloudSettings = <ThrowOnError extends boolean = false>(options?: Options<GetCloudSettingsData, ThrowOnError>) => (options?.client ?? client).get<GetCloudSettingsResponses, GetCloudSettingsErrors, ThrowOnError>({ url: '/cloud/settings', ...options });

/**
 * Update Cloud Settings
 *
 * Persist and activate new cloud settings.
 *
 * Args:
 * new_settings: The new cloud settings to persist and activate
 *
 * Returns:
 * CloudSettingsResponse: A response object containing the masked active cloud configuration
 */
export const updateCloudSettings = <ThrowOnError extends boolean = false>(options: Options<UpdateCloudSettingsData, ThrowOnError>) => (options.client ?? client).post<UpdateCloudSettingsResponses, UpdateCloudSettingsErrors, ThrowOnError>({
    url: '/cloud/settings',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * List Cloud Projects
 *
 * Return all local projects enriched with cloud metadata.
 *
 * Returns:
 * list[CloudProjectStatus]: A list of cloud project status objects
 */
export const listCloudProjects = <ThrowOnError extends boolean = false>(options?: Options<ListCloudProjectsData, ThrowOnError>) => (options?.client ?? client).get<ListCloudProjectsResponses, ListCloudProjectsErrors, ThrowOnError>({ url: '/cloud/projects', ...options });

/**
 * Reset Cloud Project
 *
 * Reset the remote project and clear the local linkage.
 *
 * Args:
 * project_name: The name of the project to reset the remote project for
 *
 * Returns:
 * dict[str, Any]: A response object containing the result of the reset operation
 */
export const resetCloudProject = <ThrowOnError extends boolean = false>(options: Options<ResetCloudProjectData, ThrowOnError>) => (options.client ?? client).delete<ResetCloudProjectResponses, ResetCloudProjectErrors, ThrowOnError>({ url: '/cloud/projects/{project_name}', ...options });

/**
 * Get Cloud Project
 *
 * Return cloud details for a single local project.
 *
 * Args:
 * project_name: The name of the project to get the cloud details for
 *
 * Returns:
 * CloudProjectStatus: A response object containing the cloud project status
 */
export const getCloudProject = <ThrowOnError extends boolean = false>(options: Options<GetCloudProjectData, ThrowOnError>) => (options.client ?? client).get<GetCloudProjectResponses, GetCloudProjectErrors, ThrowOnError>({ url: '/cloud/projects/{project_name}', ...options });

/**
 * Start Focus Stacking
 *
 * Start focus stacking for a scan.
 */
export const startFocusStacking = <ThrowOnError extends boolean = false>(options: Options<StartFocusStackingData, ThrowOnError>) => (options.client ?? client).post<StartFocusStackingResponses, StartFocusStackingErrors, ThrowOnError>({ url: '/projects/{project_name}/scans/{scan_index}/focus-stacking/start', ...options });

/**
 * Pause Focus Stacking
 *
 * Pause an active focus stacking task.
 */
export const pauseFocusStacking = <ThrowOnError extends boolean = false>(options: Options<PauseFocusStackingData, ThrowOnError>) => (options.client ?? client).patch<PauseFocusStackingResponses, PauseFocusStackingErrors, ThrowOnError>({ url: '/projects/{project_name}/scans/{scan_index}/focus-stacking/pause', ...options });

/**
 * Resume Focus Stacking
 *
 * Resume a paused focus stacking task.
 */
export const resumeFocusStacking = <ThrowOnError extends boolean = false>(options: Options<ResumeFocusStackingData, ThrowOnError>) => (options.client ?? client).patch<ResumeFocusStackingResponses, ResumeFocusStackingErrors, ThrowOnError>({ url: '/projects/{project_name}/scans/{scan_index}/focus-stacking/resume', ...options });

/**
 * Cancel Focus Stacking
 *
 * Cancel an active focus stacking task.
 */
export const cancelFocusStacking = <ThrowOnError extends boolean = false>(options: Options<CancelFocusStackingData, ThrowOnError>) => (options.client ?? client).patch<CancelFocusStackingResponses, CancelFocusStackingErrors, ThrowOnError>({ url: '/projects/{project_name}/scans/{scan_index}/focus-stacking/cancel', ...options });
