import { readFileSync, writeFileSync, mkdirSync } from 'node:fs';
import path from 'node:path';
import { fileURLToPath } from 'node:url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const projectRoot = path.resolve(__dirname, '..');
const openapiPath = path.resolve(projectRoot, '../openapi_v0.5.json');
const outputDir = path.resolve(projectRoot, 'src/generated/api');
const outputPath = path.resolve(outputDir, 'fieldDescriptions.ts');

const rawSpec = readFileSync(openapiPath, 'utf-8');
const spec = JSON.parse(rawSpec);
const schemas = spec.components?.schemas ?? {};

const sortObject = (input) => Object.keys(input)
  .sort((a, b) => a.localeCompare(b))
  .reduce((acc, key) => {
    acc[key] = input[key];
    return acc;
  }, {});

const collectDescriptions = (schema) => {
  if (!schema || typeof schema !== 'object') {
    return {};
  }

  if (schema.$ref) {
    const refName = schema.$ref.split('/').at(-1);
    return collectDescriptions(schemas[refName]);
  }

  let descriptions = {};

  if (schema.allOf) {
    for (const part of schema.allOf) {
      descriptions = { ...descriptions, ...collectDescriptions(part) };
    }
  }

  if (schema.anyOf) {
    for (const part of schema.anyOf) {
      descriptions = { ...descriptions, ...collectDescriptions(part) };
    }
  }

  if (schema.oneOf) {
    for (const part of schema.oneOf) {
      descriptions = { ...descriptions, ...collectDescriptions(part) };
    }
  }

  if (schema.properties) {
    for (const [propertyName, propertySchema] of Object.entries(schema.properties)) {
      if (propertySchema && typeof propertySchema === 'object') {
        if (propertySchema.description) {
          descriptions[propertyName] = propertySchema.description;
        }

        if (!descriptions[propertyName]) {
          const nested = collectDescriptions(propertySchema);
          if (nested && typeof nested === 'object' && Object.keys(nested).length === 1 && nested[propertyName]) {
            descriptions[propertyName] = nested[propertyName];
          }
        }
      }
    }
  }

  return descriptions;
};

const fieldDescriptions = Object.entries(schemas)
  .reduce((acc, [schemaName, schema]) => {
    const descriptions = collectDescriptions(schema);
    const cleaned = Object.fromEntries(Object.entries(descriptions).filter(([, value]) => Boolean(value)));

    if (Object.keys(cleaned).length > 0) {
      acc[schemaName] = sortObject(cleaned);
    }

    return acc;
  }, {});

mkdirSync(outputDir, { recursive: true });

const content = `/* eslint-disable */\n// This file is auto-generated by scripts/generate-field-descriptions.mjs\n\nexport const fieldDescriptions = ${JSON.stringify(sortObject(fieldDescriptions), null, 2)} as const;\n\nexport type FieldDescriptions = typeof fieldDescriptions;\n\nexport const getFieldDescription = <S extends keyof FieldDescriptions, F extends keyof FieldDescriptions[S]>\n  (schema: S, field: F) => fieldDescriptions[schema][field];\n`;

writeFileSync(outputPath, content);
